## 提出问题

1、`1 << 31 `和 `2 ** 31` 值分别为多少
2、`~0 `和`~-1`值分别为多少，怎么计算的
3、`(2 ** 31  - 1) << 1`， `(2 ** 31  + 1) << 1` 分别为多少
4、`(2 ** 31 - 1) & -1` ，`(2 ** 31 + 1) & -1`为多少，是否等于` -1 >>> 0`

如果上述例子都知道结果和原因，那么本文就不需要往下读了。

---

## 规范

之所以疑惑上述例子，其实是因为两个规范没理解
**`1. ECMA-262规定所有的数进行位运算都会先转换成有符号32位整数(-2 ** 31 ~ 2 ** 31 - 1)后、再进行运算`**

![image](https://wiki.huawei.com/vision-file-storage/api/file/download/upload-v2/WIKI202505106787498/22002273/66da1a3757ec4e1dbd55543f5124361d.png)

**`2. 在计算机中，数值均用补码的形式来存储 （个人理解：二进制数据都是以补码的形式存储和计算，与十进制进行转换需要使用原码）`**

---

### 依照着这两条规范、现在再来解答上述例子：

1、`1 << 31`、位运算参数和返回值都必须是`有符号32位整数`：得到的结果是`10000000000000000000000000000000`，最高位的`1`为符号位， 理论上应该是`-0`， 但是有符号32位整数范围是`-2147483648 ~ 2147483647`，因此结果应该是`-2147483648`。`2 ** 31` 没有进行位运算，无需转化成`有符号32位整数`，因此结果为`2147483648`。

2、`~-1`，进行了位运算，首先转化成`有符号32位整数`：注意，负数在计算机中以`补码`的形式存在，具体的计算规则是先转化成`反码`，`10000000000000000000000000000001(原码) => 111111111111111111111111111111110(反码) => 11111111111111111111111111111111(补码)`。`~`运算符是按位取反，也就是每一位都取反，因此得到的最终结果为`00000000000000000000000000000000`，有符号32位，计算出来为0。

3、`2 ** 31 - 1` 转化成`有符号32位整数`为： `01111111111111111111111111111111` 、这里给大家推荐一个十进制转换二进制的小技巧，可以直接在浏览器控制台通过`toString(2)方法转换`，如下图：

![image](https://wiki.huawei.com/vision-file-storage/api/file/download/upload-v2/WIKI202505106787498/22003773/13f1bc859f174db0ac5fa01a944d4903.png)

左移一位后变成了 `11111111111111111111111111111110`，注意，此时是补码，最高为`1`表示是负数(如果是正数无需处理，正数的补码等于其自身)，需要计算其原码然后再转化为`十进制`： `11111111111111111111111111111110(补码) =>  11111111111111111111111111111101(反码) => 10000000000000000000000000000010(原码)`，最终得到十进制结果为`-2`。

4、`(2 ** 31 - 1) & -1`需要将两个数都转化成`有符号32位整数`后进行运算：`-1` 为负数需要计算补码：`10000000000000000000000000000001（原码） =>  11111111111111111111111111111110（反码） =>  11111111111111111111111111111111(补码)`，和`01111111111111111111111111111111`按位与后得到了`01111111111111111111111111111111`，也就是`2147483647`

`(2 ** 31 + 1) `的二进制数据为 `10000000000000000000000000000001`， 和`-1`按位与后还是自身，但此时是负数了，需要计算原码，最后得到的结果是`-2147483647`

这里需要介绍下无符号右移动`>>>`，先看`规范`:

![image](https://wiki.huawei.com/vision-file-storage/api/file/download/upload-v2/WIKI202505106787498/22004419/2b92318c54394ea4a9b4c8648401f2f9.png)

简单来说，无符号右移也是`32位整数`，且都是正数嘛，最高位肯定是`0`，所以右移最高位补`0`

进行运算前需要把两个数都转化成无符号 `ToUnit(32)`，我们看看规范怎么描述的：

![image](https://wiki.huawei.com/vision-file-storage/api/file/download/upload-v2/WIKI202505106787498/22004442/9a1f8a84ebf64048afd1ea3d7a154528.png)

我理解就是把符号位置为`0`，也就是`Math.abs`， 所以 `-1 >>> 0` 等同于将`-1`置为无符号，也就是`Math.abs(-1)`

另外任意一个数`a`(整数/小数), `a | 0` 等价于 `a >> 0` 和 `a << 0`，通常用来取整。

---

### 很酷的应用

所以位运算到底有什么用呢，下面隆重介绍一下用位运算实现一个`Math.random`

首先需要介绍`Math.imul`，先看官方介绍

![image](https://wiki.huawei.com/vision-file-storage/api/file/download/upload-v2/WIKI202505106787498/22004517/78d70401f62c4e26b895e9128bd85de0.png)

简单来说，我们实现一个`随机数`，可以用一个`seed`乘以一个`质数`，不停地相乘。但是要保证不越界，一直在某个范围内，这时候就可以使用`Math.imul`(本质上就是`(a | 0) * (b | 0)`)，因为进行了位运算就可以实现在`（-2 ** 31 ~ 2 ** 31 - 1）`内

剩下就只需要解决一个问题：负数怎么处理？因为`Math.random`返回的是`[0~1)`的随机数。我们可以把结果按位 `& (2 ** 31 - 1)`， 这样就能保证符号位肯定为正了，下面展示代码：

```
class Random {
     constructor(seed) {
         this.seed = seed;
     }
     next() {
        if (this.seed) {
              return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;
         }
         else {
              return Math.random();
          }
     }
 }

```

思考一下 如果不按位 `& (2 ** 31 - 1)`，而是使用` >>>`，结果会是一样的吗？

最后，位运算在算法中有着不可替代的作用，可以让代码变得非常简洁明了。我收集了几道[位运算相关的题目](https://leetcode.cn/problem-list/oc87J1N4/)，大家可以抽空了解下。
